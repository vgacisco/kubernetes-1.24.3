#! /bin/bash
# 维护者: vgacisco
#
# version: v1.0

# 配置 PATH
workdir=`pwd`
export PATH=$PATH:$workdir/../bin

# 先生成 pem文件

# 生成 ca pem文件
ca_jsons=(etcd-ca front-proxy-ca kubernetes-ca)

for file in ${ca_jsons[*]};do
    echo $file
    cfssl gencert -initca $file.json|cfssljson -bare $file
done

#生成 etcd pem文件
cert_jsons=(etcd-client etcd-server)
for file in ${cert_jsons[*]};do
    file_name=$file.json
    cfssl gencert -ca etcd-ca.pem -ca-key etcd-ca-key.pem -config config.json -profile etcd $file_name |cfssljson -bare $file
done

# 生成kube-apiserver kube-controller-manager kube-scheduler kube-proxy  admin

cert_jsons=(kube-apiserver kube-controller-manager kube-scheduler kube-proxy admin)
for file in ${cert_jsons[*]};do
    cfssl gencert -ca kubernetes-ca.pem -ca-key kubernetes-ca-key.pem -config config.json -profile kubernetes $file.json |cfssljson -bare $file
done

# 生成front-proxy-client
cfssl gencert -ca front-proxy-ca.pem -ca-key front-proxy-ca-key.pem -config config.json -profile kubernetes front-proxy-client.json | cfssljson -bare front-proxy-client

# 生成签证书对 sa.pub sa.key
openssl genrsa -out sa.key 2048
openssl rsa -in sa.key -pubout -out sa.pub

# 生成kubeconfig文件

kubeconfigs=(kube-controller-manager kube-scheduler kube-proxy admin)
for kubeconfig in ${kubeconfigs[*]};do
    kubeconfig_filename=${kubeconfig}.kubeconfig
    kubeconfig_ca=$(cat kubernetes-ca.pem |base64 -w 0)
    kubeconfig_user_cert=$(cat $kubeconfig.pem |base64 -w 0)
    kubeconfig_user_key=$(cat $kubeconfig-key.pem |base64 -w 0)
    kubeconfig_user_name=$kubeconfig
    kubeconfig_cluster_name="kubernetes"
    kubeconfig_context_name="default"

    sed -e "s/__CA__/$kubeconfig_ca/"  \
        -e "s/__SERVER__/https:\/\/127.0.0.1:6443/"  \
        -e "s/__USER_NAME__/$kubeconfig_user_name/"  \
        -e "s/__CLIENT_CERT__/$kubeconfig_user_cert/"  \
        -e "s/__CLIENT_KEY__/$kubeconfig_user_key/"  \
        -e "s/__CLUSTER_NAME__/$kubeconfig_cluster_name/"  \
        -e "s/__CONTEXT_NAME__/$kubeconfig_context_name/"  \
        kubeconfig_cert.mode \
        > $kubeconfig_filename

done

# 生成bootstrap.kubeconfig 和 bootstrap-token文件 

a=$(head -c 16 /dev/urandom |md5sum | head -c 6)
b=$(head -c 16 /dev/urandom |md5sum | head -c 16)


cat > bootstrap-token.yaml <<EOF
apiVersion: v1
kind: Secret
metadata:
  # name 必须是 "bootstrap-token-<token id>" 格式的
  name: bootstrap-token-$a
  namespace: kube-system

# type 必须是 'bootstrap.kubernetes.io/token'
type: bootstrap.kubernetes.io/token
stringData:
  # 供人阅读的描述，可选。
  description: "The default bootstrap token generated by 'kubeadm init'."

  # 令牌 ID 和秘密信息，必需。
  token-id: "$a"
  token-secret: "$b"

  # 允许的用法
  usage-bootstrap-authentication: "true"
  usage-bootstrap-signing: "true"

  # 令牌要认证为的额外组，必须以 "system:bootstrappers:" 开头
  auth-extra-groups: system:bootstrappers:worker,system:bootstrappers:ingress
EOF

kubeconfig="bootstrap"
kubeconfig_filename=${kubeconfig}.kubeconfig
kubeconfig_ca=$(cat kubernetes-ca.pem |base64 -w 0)
kubeconfig_token="$a.$b"
kubeconfig_user_name=$kubeconfig
kubeconfig_cluster_name="kubernetes"
kubeconfig_context_name="$kubeconfig@$kubeconfig_cluster_name"

sed -e "s/__CA__/$kubeconfig_ca/"  \
    -e "s/__SERVER__/https:\/\/127.0.0.1:6443/"  \
    -e "s/__USER_NAME__/$kubeconfig_user_name/"  \
    -e "s/__TOKEN__/$kubeconfig_token/"  \
    -e "s/__CLUSTER_NAME__/$kubeconfig_cluster_name/"  \
    -e "s/__CONTEXT_NAME__/$kubeconfig_context_name/"  \
    kubeconfig_token.mode \
    > $kubeconfig_filename




#################################################################################

#
# 这里生成 calico yaml 文件，从 calico.yaml.mode 生成
#

#################################################################################


etcd_ca=$(cat etcd-ca.pem| base64 -w 0)
etcd_key=$(cat etcd-client-key.pem |base64 -w 0)
etcd_cert=$(cat etcd-client.pem |base64 -w 0)

sed -e "s/__ETCD_CA__MYSET__/$etcd_ca/" \
    -e "s/__ETCD_KEY__MYSET__/$etcd_key/" \
    -e "s/__ETCD_CERT__MYSET__/$etcd_cert/" \
    calico-etcd.yaml.mode \
    > calico-etcd.yaml.j2

